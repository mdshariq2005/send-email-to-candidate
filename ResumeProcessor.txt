package SendEmail;
import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.gson.GsonFactory;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.gmail.Gmail;
import com.google.api.services.gmail.GmailScopes;
import com.google.api.services.gmail.model.Message;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.FilenameUtils;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.PDFTextStripper;
import javax.mail.Session;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class ResumeProcessor {
   // private static final Logger logger = LogManager.getLogger(ResumeProcessor.class);
    private static final String WATCH_FOLDER = "C:\\Users\\Shariq.Mohd\\Downloads";
    private static final String SKILLED_RESUMES_FOLDER = "C:\\Skilled_Resumes";
    private static final String APPLICATION_NAME = "Resume Processor";
    private static final GsonFactory JSON_FACTORY = GsonFactory.getDefaultInstance();
    private static final String TOKENS_DIRECTORY_PATH = "tokens";
    private static final String CREDENTIALS_FILE_PATH = "/credentials.json";
    private static final String SKILLS_FILE_PATH = "/skills.txt";
    private static final List<String> SCOPES = Collections.singletonList(GmailScopes.GMAIL_SEND);
    private static Gmail gmailService;
    private static final Set<String> processedFiles = new HashSet<>();
    private static final long COOLDOWN_PERIOD = 5000; // 5 seconds cooldown
    private static List<String> targetSkills = new ArrayList<>();

    public static void main(String[] args) {
        try {
            // Load skills from file
            loadSkills();
            System.out.println("Loaded target skills: " + targetSkills);

            // Create required directories
            Files.createDirectories(Paths.get(SKILLED_RESUMES_FOLDER));
            Files.createDirectories(Paths.get(WATCH_FOLDER));

            // Initialize Gmail service
            final NetHttpTransport HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
            gmailService = getGmailService(HTTP_TRANSPORT);

            System.out.println("Starting resume monitoring in folder: " + WATCH_FOLDER);

            WatchService watchService = FileSystems.getDefault().newWatchService();
            Path path = Paths.get(WATCH_FOLDER);
            path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE);

            System.out.println("Watching for new resumes in: " + WATCH_FOLDER);

            while (true) {
                WatchKey key = watchService.take();
                for (WatchEvent<?> event : key.pollEvents()) {
                    if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE) {
                        Path fileName = (Path) event.context();
                        String absolutePath = path.resolve(fileName).toString();

                        // Skip temporary files
                        if (fileName.toString().toLowerCase().endsWith(".tmp") || 
                            fileName.toString().startsWith("~$") ||
                            fileName.toString().startsWith(".")) {
                            continue;
                        }

                        // Only process PDF and TXT files
                        if (!fileName.toString().toLowerCase().endsWith(".pdf") && 
                            !fileName.toString().toLowerCase().endsWith(".txt")) {
                            System.out.println("Ignoring non-supported file: " + fileName);
                            continue;
                        }

                        if (!processedFiles.contains(absolutePath)) {
                            processedFiles.add(absolutePath);
                            System.out.println("New file detected: " + absolutePath);

                            // Wait for file to be stable
                            waitForFileStability(absolutePath);
                            
                            // Process the file
                            processNewResume(absolutePath);

                            // Schedule removal from processed files after cooldown
                            new Thread(() -> {
                                try {
                                    Thread.sleep(COOLDOWN_PERIOD);
                                    processedFiles.remove(absolutePath);
                                    System.out.println("Removed " + absolutePath + " from processed files");
                                } catch (InterruptedException e) {
                                    System.err.println("Cooldown interrupted: " + e.getMessage());
                                }
                            }).start();
                        } else {
                            System.out.println("File already being processed: " + absolutePath);
                        }
                    }
                }
                key.reset();
            }
        } catch (Exception e) {
            System.err.println("Error in main process: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void loadSkills() throws IOException {
        try (InputStream in = ResumeProcessor.class.getResourceAsStream(SKILLS_FILE_PATH);
             BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {
            targetSkills = reader.lines()
                    .map(String::trim)
                    .filter(s -> !s.isEmpty())
                    .map(String::toLowerCase)
                    .collect(Collectors.toList());
            
            if (targetSkills.isEmpty()) {
                throw new IOException("No skills found in skills.txt");
            }
        } catch (Exception e) {
           // logger.error("Error loading skills file: {}", e.getMessage());
        	 System.err.println("Error loading skills file: " + e.getMessage());
            throw e;
        }
    }

    private static void processNewResume(String filePath) {
        try {
            //logger.info("Processing resume: {}", filePath);
        	System.out.println("Processing resume: " + filePath);

            Path sourcePath = Paths.get(filePath);
            if (!Files.exists(sourcePath)) {
               // logger.warn("File no longer exists: {}", filePath);
            	System.out.println("File no longer exists: " + filePath);
                return;
            }

            String content = readFileContent(filePath).toLowerCase();
            List<String> foundSkills = findMatchingSkills(content);
            
            if (!foundSkills.isEmpty()) {
                String email = extractEmail(content);
                if (email != null) {
                    sendEmail(email, foundSkills);
                   // logger.info("Email sent to: {} regarding skills: {}", email, foundSkills);
                    System.out.println("Email sent to: " + email + " regarding skills: " + foundSkills);
                } else {
                    //logger.warn("No email found in resume");
                	System.out.println("No email found in resume");
                }

                // Move file to skilled resumes folder with skills in filename
                String skillsString = String.join("_", foundSkills);
                String newFileName = sourcePath.getFileName().toString().replaceFirst("[.][^.]+$", "") 
                                   + "_" + skillsString 
                                   + "." + FilenameUtils.getExtension(sourcePath.getFileName().toString());
                Path targetPath = Paths.get(SKILLED_RESUMES_FOLDER, newFileName);
                Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                //logger.info("File moved to skilled resumes folder: {}", targetPath);
                System.out.println("File moved to skilled resumes folder: " + targetPath);
            } else {
                //logger.info("No matching skills found in resume");
            	 System.out.println("No matching skills found in resume");
                Files.delete(sourcePath);
                //logger.info("File deleted: {}", filePath);
                System.out.println("File deleted: " + filePath);
            }

        } catch (IOException e) {
           // logger.error("Error processing resume: {}", filePath, e);
        	 System.err.println("Error processing resume: " + e.getMessage());
        }
    }

    private static List<String> findMatchingSkills(String content) {
        return targetSkills.stream()
                .filter(skill -> content.contains(skill.toLowerCase()))
                .collect(Collectors.toList());
    }

    private static void waitForFileStability(String filePath) throws InterruptedException {
        Path path = Paths.get(filePath);
        long lastSize = -1;
        long currentSize;
        int stabilityCount = 0;
        
        while (stabilityCount < 3) {
            try {
                currentSize = Files.size(path);
                if (currentSize == lastSize) {
                    stabilityCount++;
                } else {
                    stabilityCount = 0;
                }
                lastSize = currentSize;
                Thread.sleep(1000);
            } catch (IOException e) {
               // logger.error("Error checking file size: {}", e.getMessage());
            	 System.err.println("Error checking file size: " + e.getMessage());
                break;
            }
        }
        //logger.info("File is stable: {}", filePath);
        System.out.println("File is stable: " + filePath);
    }

    private static String readFileContent(String filePath) throws IOException {
        File file = new File(filePath);
        String fileName = file.getName().toLowerCase();
        
        if (fileName.endsWith(".pdf")) {
            try (PDDocument document = PDDocument.load(file)) {
                PDFTextStripper stripper = new PDFTextStripper();
                return stripper.getText(document);
            }
        } else if (fileName.endsWith(".txt")) {
            return new String(Files.readAllBytes(file.toPath()));
        } else {
           // logger.warn("Unsupported file type: {}", fileName);
        	System.out.println("Warning: Unsupported file type: " + fileName);
            return "";
        }
    }

    private static String extractEmail(String content) {
        Pattern pattern = Pattern.compile("[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}");
        Matcher matcher = pattern.matcher(content);
        return matcher.find() ? matcher.group() : null;
    }

    private static Gmail getGmailService(final NetHttpTransport HTTP_TRANSPORT) throws IOException {
        InputStream in = ResumeProcessor.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
        if (in == null) {
            throw new FileNotFoundException("Resource not found: " + CREDENTIALS_FILE_PATH);
        }
        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));

        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(
                HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
                .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
                .setAccessType("offline")
                .build();
        LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
        Credential credential = new AuthorizationCodeInstalledApp(flow, receiver).authorize("user");

        return new Gmail.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential)
                .setApplicationName(APPLICATION_NAME)
                .build();
    }

    private static void sendEmail(String toEmail, List<String> foundSkills) throws IOException {
        try {
            Properties props = new Properties();
            Session session = Session.getDefaultInstance(props, null);

            MimeMessage emailContent = new MimeMessage(session);
            emailContent.setFrom(new InternetAddress("me"));
            emailContent.addRecipient(javax.mail.Message.RecipientType.TO, new InternetAddress(toEmail));
            emailContent.setSubject("Exciting Opportunity - Your Technical Skills Match Our Requirements");
            
            String skillsList = String.join(", ", foundSkills);
            String emailBody = String.join("\n",
            	    "Dear Candidate,",
            	    "",
            	    "I hope this email finds you well.",
            	    "",
            	    "Thank you for submitting your resume to our organization. We have carefully reviewed your profile and are impressed with your technical expertise.",
            	    "",
            	    "We are particularly interested in your experience with the following skills:",
            	    "- " + skillsList,
            	    "",
            	    "These skills align well with our current requirements, and we would like to explore potential opportunities with you. Our organization offers:",
            	    "- Competitive compensation package",
            	    "- Professional growth opportunities",
            	    "- Collaborative work environment",
            	    "- Exciting technical challenges",
            	    "",
            	    "Would you be available for an initial discussion about potential roles that match your expertise?",
            	    "",
            	    "Please reply to this email with your preferred date and time for a conversation.",
            	    "",
            	    "Looking forward to speaking with you.",
            	    "",
            	    "Best regards,",
            	    "Technical Recruitment Team",
            	    "XYZ Company",
            	    "",
            	    "Note: This is an automated email. Please do not reply to this email address."
            	);

            	emailContent.setText(emailBody);

            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            emailContent.writeTo(buffer);
            byte[] rawMessageBytes = buffer.toByteArray();
            String encodedEmail = Base64.encodeBase64URLSafeString(rawMessageBytes);
            Message message = new Message();
            message.setRaw(encodedEmail);

            message = gmailService.users().messages().send("me", message).execute();
            System.out.println("Email sent successfully. Message Id: " + message.getId());
        } catch (Exception e) {
            System.err.println("Failed to send email to " + toEmail + ": " + e.getMessage());
            throw new IOException("Error sending email", e);
        }
    }
}
